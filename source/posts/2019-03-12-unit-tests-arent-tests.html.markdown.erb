---
layout: post
post_title: Unit Tests aren’t ‘tests’
date: 2019-03-12
summary_image: "/assets/images/blog/gauge_blog_image_minding-gap-bdd-executable-specs_large.jpg"
excerpt: ""
author_name: "Chad Wathington, Chief Capability Officer at ThoughtWorks"
author_image: ""
title: "Unit Tests aren’t ‘tests’ | Gauge Blog"
title_tag_of_header: "Unit Tests aren’t ‘tests’ | Gauge Blog"
meta_description: ""
meta_keywords: "Acceptance tests, unit tests, importance of acceptance tests"
---

#### Mar 12, 2019 | Chad Wathington

<%= image_tag "blog/gauge_blog_image_minding-gap-bdd-executable-specs_large.jpg", {:title => "BDD vs Executable Specifications", :alt => "BDD vs Executable Specifications"} %>

# Unit Tests aren’t ‘tests’

At ThoughtWorks, we often debate the value of our existing practices to constantly challenge ourselves and remind ourselves why we do what we do. Recently this question came up: 

> Acceptance tests (in cucumber) have become this abandoned wasteland of unmaintained good intentions. Are they even useful anymore? 

Computer scientist Glenford J Myers wrote about software testing in his seminal book The Art of Software Testing (1979). 

> Software testing is a process, or a series of processes, designed to make sure computer code
does what it was designed to do and that it does not do anything unintended. 

His book became both a manual and the inspiration for an entire field - it literally defined software testing for a generation. When Myers wrote The Art of Software testing technologists often confused *testing* with *debugging* - one only needed to write a program and fix any errors you encountered by running it. Myers' broad point was that developers needed to test code to ensure it worked as designed, which requires a specification. And beyond design, tests should also seek to uncover unintended behavior. 
