---
layout: post
post_title: Taiko; a browser automation tool that's different
date: 2019-07-04
summary_image: "/assets/images/blog/taiko_comparison_blogpost_image_small.jpg"
excerpt: "Taiko is designed to be simple, reliable and a fast browser automation tool.
Comparing it with other popular open source tools to find how different it really is."
author_name: "Soumya Gupta and Nivedha Senthil"
author_image: "/assets/images/blog/taiko_comparison_authors.png"
title: "Taiko; a browser automation tool that's different | Gauge Blog"
title_tag_of_header: "Taiko: a browser automation tool that's different | Gauge Blog"
meta_description: "Taiko; a browser automation tool that's different"
meta_keywords: "Acceptance tests, end to end tests, browser automation"
---

#### July 4, 2019 | Soumya Gupta, Nivedha Senthil

<%= image_tag "/assets/images/blog/taiko_comparison_blogpost_image_large.jpg", {:title => "Taiko Comparison", :alt => "Taiko Comparison"} %>

# Taiko; browser automation tool that's different

There are a lot of free and open source tools to automate the browser and write end to end tests. Last year the Gauge team released Taiko, a browser automation tool. You may think it is yet another tool in the market. But, in this blog, we will discuss what’s different about it.

To do that we compare Taiko to Selenium, WebdriverIO, TestCafe, Cypress and Puppeteer. We compare cost of writing and maintaining tests, performance, reliability (not flaky), browser support, ease of test failure analysis and integration with other runners.  We hope this also explains how taking a different approach to write tests can be better.

<%= image_tag "blog/taiko_comparison_infographic_blog_post.png", {:title => "Taiko Infographic", :alt => "Taiko Infographic" , :class => "infographic--img"}  %>

<span class="infographic--summary">Check <a href="https://github.com/getgauge-contrib/compareBrowserAutomationTools" target="_blank">CompareBrowserAutomationTools</a>, a GitHub repository to validate our claims made in this blog.</span>


## Maintenance
> “Maintaining locators must be calculated as part of test maintenance cost.” - <a href="https://blog.mozilla.org/fxtesteng/2013/09/26/writing-reliable-locators-for-selenium-and-webdriver-tests/" target="_blank">FireFox Test Engineering</a> blog

<strong>Claim:</strong> Using XPath, ID, CSS Query selectors or other white box testing techniques increase test maintenance costs. 

Minor changes in code or page structure breaks tests even when there’s no change in functionality. Taiko’s API treats the browser like a black box. Tests written in Taiko are resilient to page structure changes.

<strong>Validation:</strong> A github <a href="https://github.com/getgauge-contrib/compareBrowserAutomationTools/tree/master/compareCostOfSelectorMaintenance" target="_blank">example</a> of todomvc automated using all these tools. All the tests currently pass for <a href="http://todomvc.com/examples/react/#/" target="_blank"> react flavour of the TODO app</a>.  However only Taiko passes when the tests run against <a href="http://todomvc.com/examples/angularjs/#/!" target="_blank">angular flavor of it</a>.

## Findings

<script src="https://gist.github.com/sguptatw/4d500702d4f70a618e173c6633353662.js"></script>

<strong>*</strong> For elements with no text, Taiko has proximity selectors which is independent of the HTML structure. However other tools depend on the HTML structure to perform actions on elements with no text.

## Reliable Wait Mechanisms 
> “1 in 7 of the tests written by our world-class engineers occasionally fail in a way not caused by changes to the code or tests.” - <a href="https://testing.googleblog.com/2016/05/flaky-tests-at-google-and-how-we.html?m=1" target="_blank">Google Testing blogs</a>.

<strong>Claim:</strong> Taiko implicitly waits for elements on the page before performing actions. This drastically reduces flakiness. 

While other tools provide granular and low level controls to explicitly wait for elements or time. These have a higher learning curve. If the user has to define waits explicitly, it makes the test code unpredictable. Improper configuration, inappropriate use of APIs along with ineffective handling of waits by the tool makes tests flaky. 

<strong>Validation:</strong> A github <a href="https://github.com/getgauge-contrib/compareBrowserAutomationTools/tree/master/comparePerformanceAndReliableWaitsOfTools/benchmarks" target="_blank">example</a> automated using all these 6 tools. In this example, all tools except Taiko and TestCafe need at least one/more explicit waits waits in test code. To validate it, comment all the explicit wait conditions. Run it; Please note the tests have to be run consecutively a couple of times to observe the flakiness. The details are available in the <a href="https://github.com/getgauge-contrib/compareBrowserAutomationTools/blob/master/comparePerformanceAndReliableWaitsOfTools/CompareReliableWaitMechanism.md" target="_blank">readme</a> of the project link.

## Findings
<strong>* Wait Mechanisms:</strong> Implicit waits are taken care of by the tool. Explicit waits are the ones the user handles in test code!

<strong>* Ease of use:</strong> Lesser waits in user code the easier it is!

<strong>* Reliable waiting mechanisms:</strong> Having lesser waits in test code and simple APIs reduce the probability of mistakes. Hence more reliable while writing tests.

<script src="https://gist.github.com/sguptatw/ec467e3cd2bcff2359d273b64ba95f4c.js"></script>

## Performance
Faster feedback on test failures plays a critical role in software lifecycle. Teams find it hard to work with and maintain tests that are slow. In other words, automated tests are only as effective as their feedback cycle. 

<strong>Claim:</strong> Many browser automation tools do not optimize performance.

<strong>Validation:</strong> <a href="https://github.com/getgauge-contrib/forToolComparison/tree/master/comparePerformanceAndFlakinessOfTools" target="_blank">A github example automated using all these 6 tools</a>. To validate it, we ran all the tests sequentially multiple times. More details of the run are given in the <a href="https://github.com/getgauge-contrib/compareBrowserAutomationTools/blob/master/comparePerformanceAndReliableWaitsOfTools/ComparePerfomance.md" target="_blank">readme</a> of the project link.

## Findings
Here are some results of benchmark tests. Lesser time and lesser CPU denotes better performance. 

<script src="https://gist.github.com/sguptatw/16d410e448df74f408a25f0422aa4767.js"></script>

<strong>*</strong> Testcafe’s execution time would have been 16 seconds if there is no reload done between each test, that adds up an overhead of 4 seconds to the test suite.<br/>

<strong>*</strong> Selenium: Performance measurement of this greatly affected by the arbitrary waits added to reduce flakiness. Optimizations may be possible by awaiting relevant condition(s).<br/>

<strong>*</strong> Since Selenium, Puppeteer and Taiko can integrate with any test runner they can use runner's parallel execution feature to boost performance. <br/>

<strong>*</strong> <a href="https://webdriver.io/docs/organizingsuites.html" target="_blank">WebdriverIO</a> and <a href="https://devexpress.github.io/testcafe/documentation/using-testcafe/common-concepts/concurrent-test-execution.html" target="_blank">TestCafe</a> has inbuilt parallelisation support.<br/>

<strong>*</strong> However, running parallel tests in cypress is a <a href="https://www.cypress.io/pricing/" target="_blank">paid dashboard service</a>.

## Ease of test failure analysis

The first step whenever a failed test occurs in test automation is to figure out why a test failed. Different tools have their own  ways for analysing test failures

<strong>Claim:</strong> Tools must make it easy to analyse test failures. Contextual data allows easier analysis.

## Findings:

<script src="https://gist.github.com/sguptatw/a14077fcea38f0dc6ebe3e1764821caa.js"></script>

* Since Selenium, Taiko and Puppeteer can integrate with any test runner they can take advantage of the runner’s debugging support. Ex:- <a href="https://github.com/getgauge/html-report" target="_blank">HTML reports</a> in <a href="https://gauge.org/" target="_blank">Gauge</a> (open source test runner)

* The <a href="https://www.cypress.io/pricing/" target="_blank">paid dashboard services</a> of cypress has more options for test failure analysis on CI/CD environments.

## Cross browser support
<strong>Claim:</strong> Not all tools supports cross browser testing

## Findings

<script src="https://gist.github.com/sguptatw/cbbb63b46b8d68438d98640d50088a3b.js"></script>

## Language support (to write Test Code)
 <strong>- Selenium -</strong> Wide Choice of Language <br/>
 <strong>- WebdriverIO -</strong> Javascript or Typescript<br/>
 <strong>- Cypress -</strong> Javascript or Typescript<br/>
 <strong>- Testcafe -</strong> Javascript or Typescript<br/>
 <strong>- Taiko -</strong> Javascript<br/>
 <strong>- Puppeteer -</strong> Javascript or Typescript<br/>

## Test Runner integration

<script src="https://gist.github.com/sguptatw/a999b15bb779dc6845786fcd3b4542a8.js"></script>


## Here are a few miscellaneous aspects

<strong>Cypress:</strong> The <a href="https://www.cypress.io/pricing/" target="_blank">commercial component Cypress Dashboard</a> is a service that gives you access to recorded tests - when running Cypress tests from your <a href="https://docs.cypress.io/guides/guides/continuous-integration.html" target="_blank">CI provider</a>. The Dashboard provides you insights about tests runs.

<strong>WebDriverIO:</strong> Has support for integration with cloud platforms to aid cross browser testing under its <a href="https://webdriver.io/docs/cloudservices.html" target="_blank">cloud services</a>.

<strong>Puppeteer:</strong> This is very fast. Puppeteer is designed to cover wider accepts of browser automation. Test automation is not the focus of Puppeteer. Maybe that’s why the learning curve associated to automate browser tests is high.

<strong>Taiko:</strong> Unlike a UI recorder, Taiko’s REPL takes instructions given in the terminal and performs the action on the browser. The user can continue to give instructions to complete a workflow. Only successful actions are recorded as a script. This generates human readable code and keeps the learning curve low.

As always, there will be pro's and con's for each of these tools. For instance, If you are looking for something with cross browser support, Selenium or WebDriverIO is a good fit. But, if you are looking for a cost effective and reliable web browser automation tool, it’s worth considering Taiko.

If you have come across a tool that’s worked well for you and is not on the list, please leave a comment below!


